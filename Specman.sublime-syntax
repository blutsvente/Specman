%YAML 1.2
---
name: Specman
file_extensions:
  - e

# Comments refer to chapters in the Specman e Language reference

# The default scope for specman is text, only the code between <' '> is considered source
scope: text.specman

variables:
  types: (list of \w*|locker|address|body|code|vec|chars|integer|real|bool|int|long|uint|byte|bits|bit|time|string|byte_array|external_pointer)
  valid_name: ([a-zA-Z](?:[a-zA-Z0-9_]+)?)
  valid_type: ((?:list\s+of\s+)?[a-zA-Z](?:[a-zA-Z0-9_]+)?(?:\s*\(\s*bits\s*:\s*\d+\s*\))?)

contexts:
  main:
    # 1.1.2 Code segments
    - match: ^(<')
      scope: punctuation.section.source.begin.specman
      push: source

  comments:
    # 1.1.3 Comments and White space
    - match: (//|--)
      scope: punctuation.definition.comment.specman
      push: comment-contents

  comment-contents:
    - meta_scope: comment.line.specman
    - match: \n
      pop: true

  string:
    - meta_scope: string.quoted.double.specman
    - match: \\n|\\t|\\f|\\"|\\\\|\\r
      scope: constant.character.escape.specman
    - match: '"'
      scope: punctuation.definition.string.end.specman
      pop: true

  literals:
    # 1.1.4.3 MVL literals

    - match: \b((\d+)(')([oO])[0-7]([0-7xXzZuUlLhHwWnN_]+)?)\b
      captures:
        1: constant.numeric.mvl.octal.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)(')([hHxX])[0-9a-fA-F]([0-9a-fA-FxXzZuUlLhHwWnN_]+)?)\b
      captures:
        1: constant.numeric.mvl.hex.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)(')([bB])[0-1]([0-1xXzZuUlLhHwWnN_]+)?)\b
      captures:
        1: constant.numeric.mvl.binary.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    # 1.1.4.1 Unsized numbers
    - match: \b(-?([0-9_]+[kKmM]?))\b
      scope: constant.numeric.unsized.integer.specman

    - match: \b(0([bB])\s*[0-1_xXzZ?]+)\b
      captures:
        1: constant.numeric.unsized.binary.specman
        2: storage.modifier.constant.type.specman

    - match: \b(0([xX])\s*[0-9a-fA-F_xXzZ?]+)\b
      captures:
        1: constant.numeric.unsized.hex.specman
        2: storage.modifier.constant.type.specman

    - match: \b(0([oO])\s*[0-9a-fA-F_xXzZ?]+)\b
      captures:
        1: constant.numeric.unsized.octal.specman
        2: storage.modifier.constant.type.specman

    # 1.1.4.2 Sized numbers

    - match: \b((\d+)?(')([dD])\s*[0-9_]+)\b
      captures:
        1: constant.numeric.sized.integer.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)?(')([bB])\s*[0-1_]+)\b
      captures:
        1: constant.numeric.sized.binary.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)?(')([hHxX])\s*[0-9a-fA-F_]+)\b
      captures:
        1: constant.numeric.sized.hex.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)?(')([oO])\s*[0-7_]+)\b
      captures:
        1: constant.numeric.sized.octal.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    # 1.1.4.4 Predefined constants
    - match: \b(TRUE|FALSE|NULL|UNDEF|MAX_INT|MIN_INT|MAX_LONGINT|MIN_LONGINT|MAX_UINT|MAX_LONGUINT)\b
      scope: constant.language.specman

    # 1.1.4.5 Literal string
    - match: '"'
      scope: punctuation.definition.string.begin.specman
      push: string

    # 1.1.4.6 Literal character
    - match: 0c"[a-zA-Z]"
      scope: constant.character.literal.specman

  struct-declaration:
    - meta_content_scope: meta.class.body.specman
    - include: comments
    - include: literals
    - include: methods
    - include: tbd
    - match: \}
      scope: punctuation.section.method.end.specman
      pop: true

  method-declaration:
    - match: (private|static|final)?(?:\s+){{valid_name}}\s*(?=\()
      captures:
        1: storage.modifier.function.specman
        2: meta.function.identifier.specman entity.name.function.specman
    - match: \(
      scope: punctuation.section.function.parameter-list.begin.specman
      push: method-parameters
    - match: :\s*{{valid_type}}
      scope: meta.function.return-type.specman storage.type.specman
    - match: (\@)([a-zA-Z0-9_.]+)
      captures:
        1: punctuation.accessor.event.specman
        2: keyword.control.function.event.specman
    - match: (is)(?:\s+)(only|first|also)?
      captures:
        1: keyword.other.function.specman
        2: keyword.modifier.function.specman
    - match: (empty)\s*;
      captures:
        1: keyword.other.function.specman;
      pop: true;
    - match: \{
      scope: punctuation.section.function.begin.specman
      push: method-body
    - match: \};
      pop: true

  method-parameters:
    - meta_content_scope: meta.function.parameters.specman
    - match: (?:{{valid_name}}\s*(:)\s*(?:(\*)?{{valid_type}}))
      captures:
        1: variable.parameter.specman
        2: punctuation.separator.parameter.specman
        3: punctuation.accessor.parameter.specman
        4: storage.type.specman
    - match: (,)
      scope: punctuation.separator.parameter.specman
    - match: \)
      scope: punctuation.section.function.parameter-list.end.specman
      pop: true

  method-body:
    - meta_content_scope: meta.function.body.specman
    - include: comments
    - include: literals
    - include: tbd
    - match: (?=\})
      scope: punctuation.section.class.end.specman
      pop: true

  source:
    - clear_scopes: true
    - meta_content_scope: source.specman
    - include: comments
    - include: literals
    - include: methods
    - include: tbd
    - match: ^('>)
      scope: punctuation.section.source.end.specman
      pop: true

    # 1.1.5.2 Macros
    - match: ^\s*(define)\b
      scope: meta.preprocessor.macro.specman keyword.control.import.define.specman
      # TODO: push onto stack and parse macro definition/define

    # 3.2.1 Struct
    - match: ^\s*(struct)(?:\s+|\b){{valid_name}}(?:\s+(like)\s+{{valid_name}})?\s*(\{)
      captures:
        1: storage.type.struct.specman
        2: meta.class.identifier.specman entity.name.class.specman
        3: keyword.declaration.like.specman
        4: entity.other.inherited-class.specman
        5: punctuation.section.class.begin.specman
      push: struct-declaration

  methods:
    - match: (?=^\s*\w+.*\s+is\s*(\s+(only|first|also)?)\s*{)
      push: method-declaration

#######

  tbd:
    - scope: keyword.statement.specman
      match: \b(var|instance|on|compute|start|event|expect|check|that|routine|specman|with|like|all|radix|hex|dec|bin|ignore|illegal|traceable|untraceable|cover|using|count_only|trace_only|at_least|transition|item|ranges|cross|text|call|task|within)\b

    - scope: variable.function.specman meta.function-call
      match: \b(initialize|non_terminal|testgroup|delayed|exit|finish|out|append|print|outf|appendf|post_generate|pre_generate|setup_test|finalize_test|extract_test|init|run|copy|as_a|set_config|dut_error|add|clear|lock|quit|lock|unlock|release|swap|quit|to_string|value|stop_run|crc_8|crc_32|crc_32_flip|get_config|add0|all_indices|and_all|apply|average|count|delete|exists|first_index|get_indices|has|insert|is_a_permutation|is_empty|key|key_exists|key_index|last|last_index|max|max_index|max_value|min|min_index|min_value|or_all|pop|pop0|push|push0|product|resize|reverse|sort|split|sum|top|top0|unique|clear|is_all_iterations|get_enclosing_unit|hdl_path|exec|deep_compare|deep_compare_physical|pack|unpack|warning|error|fatal)\b

    - scope: keyword.control.specman
      match: \b(until|repeat|while|for|from|to|step|each|do|break|continue|before|next|sequence|always|-kind|network|index|it|me|in|new|return|result|select)\b

    - scope: keyword.packing.specman
      match: \b(packing|low|high)\b

    - match: ^\s*(#\s*(?:ifdef|ifndef|else))\b
      scope: keyword.control.import.specman meta.preprocessor.specman

    - scope: keyword.conditional.specman
      match: \b(choose|matches|if|then|else|when|try)\b

    - scope: keyword.conditional.specman
      match: \b(case|casex|casez|default)\b

    - scope: keyword.operator.word.specman
      match: \b(and|or|not|xor)\b

    - scope: keyword.operator.assignment.specman
      match: (=|+=|-=|*=)

    - scope: keyword.operator.logical.specman
      match: (==|!=|>|<|===|!===|>=|<=)

    - scope: keyword.operator.arithmetic.specman
      match: (-|\+|*|/)

    - scope: keyword.operator.bitwise.specman
      match: (&|\|~|!)

    - scope: keyword.temporal.specman
      match: \b(cycle|sample|events|forever|wait|change|negedge|rise|fall|delay|sync|sim|true|detach|eventually|emit)\b

    - scope: keyword.define.specman
      match: \b(as|computed|type|extend|verilog|vhdl|variable|global|sys)\b

    - scope: entity.name.class.specman
      match: \b(unit)\b

    - scope: keyword.control.import.specman
      match: \b(import)\b

    - scope: keyword.constraint.specman
      match: \b(gen|keep|keeping|soft|before)\b

    - scope: keyword.special.specman
      match: \b(untyped|symtab|ECHO|DOECHO)\b

    - scope: keyword.file.specman
      match: \b(files|load|module|ntv|source_ref|script|read|write)\b

    - scope: keyword.fsm.specman
      match: \b(initial|idle|others|posedge|clock|cycles)\b

    - scope: storage.type.specman
      match: \b{{types}}\b
