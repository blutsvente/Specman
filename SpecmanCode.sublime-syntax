%YAML 1.2
---
name: SpecmanCode

# Note: Numbered comments refer to chapters in the Specman e Language reference
scope: source.specman
hidden: true

variables:
  scalar_types: int|uint|longint|longuint|bit|nibble|byte|time|bool
  built_in_types: ({{scalar_types}}|string|real|set|untyped|rdv_semaphore|semaphore|locker|external_pointer)
  # The following should include all keywords which are invalid as a user defined name
  built_in_functions: \bassert\b|\berror\b|\bcompute\b|\bfatal\b|\bmessagef\b|\bmessage\b|\bappendf\b|\bappend\b|\bdut_error\b|\bread_only\b|\bvalue\b|\bwarning\b
  built_in_functions_optional_parens: assert|compute
  list_pseudo_methods: add|add0|clear|delete|fast_delete|insert|pop0|pop|push0|push|resize|all_different|apply|copy|count|exists|first|first_index|flatten|get_indices|has|is_a_permutation|is_empty|last|last_index|max|max_index|max_value|min|min_index|min_value|reverse|size|sort|sort_by_field|split|top0|top|unique|all|all_indices|and_all|or_all|average|product|sum|crc_8|crc_32|crc_32_flip|key|key_index|key_exists
  built_in_member_functions: hdl_path|reset_soft
  built_in_variables: \bit\b|\bm\b|\bindex\b
  built_in_constants: TRUE|FALSE|NULL|UNDEF|MAX_INT|MIN_INT|MAX_LONGINT|MIN_LONGINT|MAX_UINT|MAX_LONGUINT
  invalid_names: \bkeep\b|\bif\b|{{built_in_functions}}|{{built_in_variables}}
  scalar_range_modifier: \[\s*[a-zA-Z0-9_]+\s*\.\.\s*[a-zA-Z0-9_]+\s*\]
  scalar_width_modifier: \(\s*(?:bits|bytes)\s*:\s*[\d\*]+\s*\)
  # Valid name that can also be a hierarchical reference
  valid_name: ([a-zA-Z](?:[a-zA-Z0-9_.]+)?(?<!{{invalid_names}}))
  # Simple valid name
  valid_id: ([a-zA-Z](?:[a-zA-Z0-9_]+)?(?<!{{invalid_names}}))
  valid_type: (?:list\s+of\s+)?{{valid_id}}\s*({{scalar_range_modifier}}\s*)?({{scalar_width_modifier}})?
  struct_access: package|protected|private
  concurrency_actions: first\s+of|all\s+of

contexts:
  main:
    - match: \b(package)\s+(.*)(;)
      captures:
        1: entity.name.namespace.specman
        2: entity.name.specman
        3: punctuation.terminator.specman
    - match: \b(import)\s+(.*)(;)
      captures:
        1: keyword.control.import.specman
        2: entity.name.filename.specman
        3: punctuation.terminator.specman

    - include: code

  prototype:
    - include: comments

  # 1.2.2 Statements
  code:
    - include: preprocessor
    - include: structs
    - include: macros
    - include: literals
    - include: operators
    - include: type-casting
    - include: built-in-function-calls
    - include: scalar-type-definition
    - include: methods
    # - include: inline-generation
    # - include: struct-allocation
    # - include: code-blocks
    - include: stray-brackets-code
    - include: tbd
    # - include: concurrency-block


  stray-brackets-code:
    # stray brackets/braces (taken from systemverilog syntax)
    - match: '\('
      push:
        - match: '\)'
          pop: true
        - match: '[^\)\n]*$(?!\n)'
          scope: invalid.illegal.unbalanced-bracket.specman
        - include: code
    - match: '\['
      push:
        - match: '\]'
          pop: true
        - match: '[^\]\n]*$(?!\n)'
          scope: invalid.illegal.unbalanced-bracket.specman
        - include: code
    - match: '\)|\]'
      scope: invalid.illegal.stray-bracket-end.specman


  # 1.1.3 Comments and White space
  comments:
    - match: (//|--)
      scope: punctuation.definition.comment.specman
      push: comment-contents

  comment-contents:
    - meta_scope: comment.line.specman
    - match: \n
      pop: true

  string:
    - meta_scope: string.quoted.double.specman
    - meta_include_prototype: false
    - match: \\n|\\t|\\f|\\"|\\\\|\\r
      scope: constant.character.escape.specman
    - match: '"'
      scope: punctuation.definition.string.end.specman
      pop: true

  literals:
    # 1.1.4.3 MVL literals
    - match: \b((\d+)(')([oO])[0-7]([0-7xXzZuUlLhHwWnN_]+)?)\b
      captures:
        1: constant.numeric.mvl.octal.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)(')([hHxX])[0-9a-fA-F]([0-9a-fA-FxXzZuUlLhHwWnN_]+)?)\b
      captures:
        1: constant.numeric.mvl.hex.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)(')([bB])[0-1]([0-1xXzZuUlLhHwWnN_]+)?)\b
      captures:
        1: constant.numeric.mvl.binary.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    # 1.1.4.1 Unsized numbers
    - match: \b(-?([0-9_]+[kKmM]?))\b
      scope: constant.numeric.unsized.integer.specman

    - match: \b(0([bB])\s*[0-1_xXzZ?]+)\b
      captures:
        1: constant.numeric.unsized.binary.specman
        2: storage.modifier.constant.type.specman

    - match: \b(0([xX])\s*[0-9a-fA-F_xXzZ?]+)\b
      captures:
        1: constant.numeric.unsized.hex.specman
        2: storage.modifier.constant.type.specman

    - match: \b(0([oO])\s*[0-9a-fA-F_xXzZ?]+)\b
      captures:
        1: constant.numeric.unsized.octal.specman
        2: storage.modifier.constant.type.specman

    # 1.1.4.2 Sized numbers
    - match: \b((\d+)?(')([dD])\s*[0-9_]+)\b
      captures:
        1: constant.numeric.sized.integer.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)?(')([bB])\s*[0-1_]+)\b
      captures:
        1: constant.numeric.sized.binary.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)?(')([hHxX])\s*[0-9a-fA-F_]+)\b
      captures:
        1: constant.numeric.sized.hex.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    - match: \b((\d+)?(')([oO])\s*[0-7_]+)\b
      captures:
        1: constant.numeric.sized.octal.specman
        2: storage.modifier.constant.size.specman
        3: punctuation.separator.literal.specman
        4: storage.modifier.constant.type.specman

    # 1.1.4.4 Predefined constants
    - match: \b({{built_in_constants}})\b
      scope: constant.language.specman

    # 1.1.4.5 Literal string
    - match: '"'
      scope: punctuation.definition.string.begin.specman
      push: string

    # 1.1.4.6 Literal character
    - match: 0c"[a-zA-Z]"
      scope: constant.character.literal.specman

  operators:
    - scope: keyword.operator.word.specman
      match: \b(and|or|not|now|in|in_table)\b

    - scope: keyword.operator.boolean.specman
      match: '(&&|\|\||!|=>)'

      # Note: we exclude the delayed assignment operator here because it is already
      # in the comparison operator match
    - scope: keyword.operator.assignment.specman
      match: '(=|\+=|-=|\*=|:=)'

    - scope: keyword.operator.comparison.specman
      match: (==|!=|>|<|===|!===|>=|<=)

    - scope: keyword.operator.arithmetic.specman
      match: (-|\+|\*|/)

    - scope: keyword.operator.bitwise.specman
      match: (&|\|~|!|\^)

  type-casting:
    # TODO: add other syntax
    - match: \.(as_a)\s*(\()
      captures:
        1: keyword.other.specman
        2: punctuation.section.parens.begin.specman
      push:
        - meta_scope: meta.type-casting.builtin.specman
        - match: (\))\s*(;)?
          pop: true
          captures:
            1: punctuation.section.parens.end.specman
            2: punctuation.terminator.specman
        - match: (?:\b{{valid_type}}\b)
          scope: storage.type.specman

  # 2.7 Defining and extending scalar types
  scalar-type-definition:
    - match: '\b(type|extend)\b\s+{{valid_id}}\s*:\s*{{valid_type}}(\s*;)?'
      scope: storage.type.specman
      captures:
        1: keyword.declaration.specman
        2: storage.type.specman
        3: storage.type.specman
        4: storage.modifier.specman
        5: storage.modifier.specman
        6: punctuation.terminator.specman
    # start of (multi-line) enum declaration
    - match: '\b(type|extend)\b\s+{{valid_id}}\s*:\s*(\[\s*)'
      captures:
        1: keyword.declaration.specman
        2: storage.type.enum.specman
        3: punctuation.brackets.begin.specman
      push: enum-values-declaration

  enum-values-declaration:
    - meta_content_scope: meta.enum.specman
    - include: literals
    - match: (\s*,)
      captures:
        1: punctuation.separator.specman
    - match: (\s*,)?(?:\s*{{valid_id}}\s*)(=\s*)?
      captures:
        1: punctuation.separator.specman
        2: constant.other.enum.specman
        3: keyword.operator.assignment
    - match: '(\]\s*)({{scalar_width_modifier}})?(\s*;)?'
      captures:
        1: punctuation.brackets.end.specman
        2: storage.modifier.specman
        3: punctuation.terminator.specman
      pop: true

  # 7.1 Defining and Extending Methods
  methods:
    - match: (?=(?:{{struct_access}})?\s*(static\s+)?(final\s+)?\s*{{valid_id}}\s*\()
      push: method-declaration

  method-declaration:
    - match: (?!\bis\b)
      pop: true
    - match: ({{struct_access}})?\s*(static\s+)?(final\s+)?\s*\b{{valid_id}}\b\s*(\()
      captures:
        1: storage.modifier.function.specman
        2: storage.modifier.function.specman
        3: storage.modifier.function.specman
        4: meta.method.identifier.specman entity.name.function.specman
        5: meta.method.parameters.specman punctuation.section.parens.begin.specman
      push: method-parameters

  method-parameters:
    - meta_content_scope: meta.method.parameters.specman
    - match: (?:{{valid_id}}\s*(:)\s*(?:(\*)?{{valid_type}}))
      captures:
        1: variable.parameter.specman
        2: punctuation.separator.parameter.specman
        3: punctuation.accessor.parameter.specman
        4: storage.type.specman
        5: storage.modifier.specman
        6: storage.modifier.specman
    - match: (,)
      scope: punctuation.separator.parameter.specman
    - match: \)\s*(;)
      scope: punctuation.section.parens.end.specman
      captures:
        1: punctuation.terminator.specman
      pop: true
    - match: \)
      scope: punctuation.section.parens.end.specman
      set: method-declaration-end

  method-declaration-end:
    - match: (:)\s*{{valid_type}}
      captures:
        1: punctuation.separator.return-type.specman
        2: meta.method.return-type.specman storage.type.specman
        3: storage.modifier.specman
        4: storage.modifier.specman
    - match: (\@){{valid_id}}
      captures:
        1: punctuation.accessor.event.specman
        2: keyword.control.function.event.specman
    - match: (is)\s+(empty|undefined)\s*(;)
      captures:
        1: keyword.other.function.specman
        2: keyword.modifier.function.specman
        3: punctuation.terminator.specman
      pop: true
    - match: (is)\s+(only|first|also)?
      captures:
        1: keyword.other.function.specman
        2: keyword.modifier.function.specman
    - match: \{
      scope: punctuation.section.method.begin.specman
      set: actions

  # 1.2.4 Actions
  actions:
    # TODO: add method calls
    - meta_content_scope: meta.actions.specman
    - include: literals
    - include: operators
    - include: type-casting
    - include: built-in-function-calls
    - include: inline-generation
    - include: struct-allocation
    - include: built-in-function-calls
    - include: variable-declaration
    - include: code-blocks
    - match: (\})\s*(;)
      captures:
        1: punctuation.section.method.end.specman
        2: punctuation.terminator.specman
      pop: true
    - include: tbd

  # 8.2 var
  variable-declaration:
    - match: '(\bvar\b)\s*(?:{{valid_id}}\s*):\s*{{valid_type}}'
      captures:
        1: keyword.declaration.specman
        2: variable.other.specman
        3: storage.type.specman
        4: storage.modifier.specman
        5: storage.modifier.specman
    - match: '(\bvar\b)\s*(?:{{valid_id}}\s*):\s*\s*(\[\s*)'
      captures:
        1: keyword.declaration.specman
        2: variable.other.specman
        3: punctuation.brackets.begin.specman
      push: enum-values-declaration
    # Implicitly typed variable
    - match: '(\bvar\b)\s*(?:{{valid_id}}\s*)(:=\s*)'
      captures:
        1: keyword.declaration.specman
        2: variable.other.specman
        3: keyword.operator.assignment

  # 1.1.5.2 Macros
  macros:
    - match: ^\s*(\bdefine\b)\s+(?:{{valid_name}}\b)
      scope: meta.preprocessor.macro.specman
      captures:
        1: keyword.control.define.specman
        2: constant.other.specman
      # TODO: push onto stack and parse macro definition for define-as and define-as-computed

  # 3.2.1 Structs
  structs:
    - match: (?=^\s*struct\s+{{valid_id}}(?:\s+(like)\s+{{valid_id}})?\s*\{)
      push: struct-declaration
    - match: (?=extend\s+({{valid_id}}\s+)+\{)
      push: struct-declaration
    - match: (?=^\s*unit\s+{{valid_id}}(?:\s+(like)\s+{{valid_id}})?\s*\{)
      push: struct-declaration

  struct-declaration:
    - match: (struct|unit)\s+{{valid_id}}(?:\s+(like)\s+{{valid_id}})?\s*(\{)
      captures:
        1: keyword.declaration.class.specman
        2: meta.class.identifier.specman entity.name.class.specman
        3: keyword.declaration.like.specman
        4: entity.other.inherited-class.specman
        5: punctuation.section.class.begin.specman
      push: struct-contents
    - match: (extend)\s+{{valid_id}}\s*(\{)
      captures:
        1: keyword.declaration.class.specman
        2: meta.class.identifier.specman entity.name.class.specman
        3: punctuation.section.class.begin.specman
      set: struct-contents
    - match: (extend)\s+(?:{{valid_id}}\s+)+(?={{valid_id}}\s*\{)
      captures:
        1: keyword.declaration.class.specman
        2: meta.class.identifier.specman entity.name.class.specman
      set:
        - match: (?:{{valid_id}}\s*)
          meta_scope: entity.other.inherited-class.specman
        - match: \{
          scope: punctuation.section.class.begin.specman
          set: struct-contents

  struct-contents:
    - meta_content_scope: meta.class.body.specman
    - include: constraint-def
    - include: code

    # 3.5 Defining Fields
    # TODO: Need to complete with [= init-value]
    # TODO: add is_instance for units
    # Match type with optional scalar modifiers
    - match: ({{struct_access}}\s+)?(static\s+)?(const\s+)?(!\s*)?(%\s*)?(?:{{valid_id}}\s*)(?:(\:)\s*{{valid_type}}\s*)\s*(;)
      captures:
        1: storage.modifier.access.specman
        2: storage.modifier.static.specman
        3: storage.modifier.const.specman
        4: punctuation.definition.variable.ungenerated.specman
        5: punctuation.definition.variable.physical.specman
        6: variable.other.specman
        7: punctuation.separator.type.specman
        8: storage.type.specman
        9: storage.modifier.specman
        10: storage.modifier.specman
        11: punctuation.terminator.specman

    - match: (\})\s*(;)
      pop: true
      captures:
        1: punctuation.section.class.end.specman
        2: punctuation.terminator.specman

  # 11.1 Defining constraints
  # In this scope, the keep statement has already been consumed; this way we can use the match patterns also
  # for block-constraints
  constraint-def:

    # TODO: Support type constraints
    - match: (\bkeep\b)\s+(?:\s*{{valid_name}})\.(reset_soft)
      captures:
        1: keyword.other.constraint.specman
        2: variable.other.specman
        3: keyword.modifier.constraint.specman

    # TODO: extend regexp for full syntax
    # for each [(item-name)] [using index (index-name)] [prev (prev-name)]] in gen-list {constraint-def | nested-for-each; ...}
    - match: (\bkeep\b)\s+(?:{{valid_id}}\s+is\s+)?(\bsoft\b)?\s*(\bfor\s+each\b)\s*(?:\(\s*{{valid_id}}\s*\)\s*)?(?:\busing\s+index\s*\(\s*{{valid_id}}\s*\)\s*)?in\s+(?:{{valid_name}})(\s*\{)
      captures:
        1: keyword.other.constraint.specman
        2: entity.name.label.specman
        3: keyword.modifier.constraint.specman
        4: keyword.control.specman
        5: variable.other.specman
        6: variable.other.specman
        7: variable.other.specman
        8: punctuation.section.constraint_block.begin.specman
      push: constraint-block

    # keep all of <block> (need '{' in same line to detect it)
    - match: (\bkeep\b)\s+(?:{{valid_id}}\s+is\s+)?(all\s+of\b)(\s*\{)
      captures:
        1: keyword.other.constraint.specman
        2: entity.name.label.specman
        3: keyword.control.specman
        4: punctuation.section.constraint_block.begin.specman
      push: constraint-block

    # implication with block: keep <expr> => [all of ] <block> (need '{' in same line to detect it)
    - match: (\bkeep\b)\s+(?:{{valid_id}}\s+is\s+)?(\bsoft\b)?\s*(.*?)\s+(=>\s+)(all\s+of\b)?(\s*\{)
      captures:
        1: keyword.other.constraint.specman
        2: entity.name.label.specman
        3: keyword.modifier.constraint.specman
        4: variable.other.specman # LHS expression
        5: keyword.operator.logical.specman
        6: keyword.control.specman
        7: punctuation.section.constraint_block.begin.specman
      push: constraint-block

    # implication without block
    # use look-ahead to allow matching the LHS expression elsewhere
    - match: (\bkeep\b)\s+(?:{{valid_id}}\s+is\s+)?(\bsoft\b)?\s*(?=(.*?)\s*(=>))
      captures:
        1: keyword.other.constraint.specman
        2: entity.name.label.specman
        3: keyword.modifier.constraint.specman
        5: keyword.operator.logical.specman

    # before
    - match: (\bkeep\b)\s+(?:{{valid_id}}\s+is\s+)?(\bsoft\b)?\s*(?:{{valid_name}}\s*)(\bbefore\b)\s*(?:{{valid_name}})(;)
      captures:
        1: keyword.other.constraint.specman
        2: entity.name.label.specman
        3: keyword.modifier.constraint.specman
        4: variable.other.specman
        5: keyword.other.constraint.specman
        6: variable.other.specman
        7: punctuation.terminator.specman

    # select
    - match: (\bkeep\b)\s+(?:{{valid_id}}\s+is\s+)?(\bsoft\b)\s*(?:{{valid_name}})\s+(==)\s+(\bselect\b)
      captures:
        1: keyword.other.constraint.specman
        2: entity.name.label.specman
        3: keyword.modifier.constraint.specman
        4: variable.other.specman
        5: keyword.operator.assignment.specman
        6: keyword.other.constraint.specman

    # all other constraints not matched above
    #- match: (\bkeep\b)\s+(\bsoft\b)?(?:\s*{{valid_name}}\s*)(in|==|!=|>=|<=|>|<)?
    - match: (\bkeep\b)\s+(?:{{valid_id}}\s+is\s+)?(\bsoft\b)?\s*
      captures:
        1: keyword.other.constraint.specman
        2: entity.name.label.specman
        3: keyword.modifier.constraint.specman

  constraint-block:
    - meta_scope: meta.block.constraint.specman
    - include: built-in-function-calls
    - include: built-in-variables

    - match: \}\s*(;)
      scope: punctuation.section.constraint_block.end.specman
      captures:
        1: punctuation.terminator.specman
      pop: true

    - include: literals
    - include: operators
    - include: tbd

  inline-generation:
    - match: \s+(gen)\s+(\w+)
      captures:
        1: keyword.other.gen.specman
        2: variable.other.member.specman
      push: inline-generation-constraint

  inline-generation-constraint:
    - meta_content_scope: meta.constraint.specman
    - match: ;
      pop: true
    - match: \bkeeping\b
      scope: keyword.other.constraint.specman
    - match: \{
      scope: punctuation.section.constraint.begin.specman
      push: inline-constraints

  inline-constraints:
    - match: \}(?=;)
      scope: punctuation.section.constraint.end.specman
      pop: true

  struct-allocation:
    - match: (?=(a\s+)?\bnew\b)
      push: struct-allocation-def

  struct-allocation-def:
    - meta_content_scope: meta.function-call.new.specman
    - match: (a\s+)?\bnew\b
      scope: variable.function.new.specman
    - match: (with)\s*(\{)
      captures:
        1: keyword.operator.assignment.specman
        2: punctuation.section.block.begin.specman
      push:
        - meta_content_scope: meta.block.action.specman
        - include: code
        - match: (?=(\})\s*(;))
          pop: true
    - match: (\})\s*(;)
      pop: true
      captures:
        1: punctuation.section.block.end.specman
        2: punctuation.terminator.specman
    - match: (?:{{valid_type}})\s*(\(\s*{{valid_name}}\s*\))?
      captures:
        1: storage.type.specman
        2: variable.other.specman
    - match: ;
      scope: punctuation.terminator.specman
      pop: true

  built-in-function-calls:
    - match: ({{built_in_functions}})\s*(\()
      captures:
        1: keyword.function.builtin.specman
        2: punctuation.section.parens.begin.specman
      push:
        - meta_scope: meta.function-call.builtin.specman
        - match: (\))\s*(;)?
          pop: true
          captures:
            1: punctuation.section.parens.end.specman
            2: punctuation.terminator.specman
        - include: code
    - match: ({{built_in_functions_optional_parens}}\s+)
      captures:
        1: keyword.function.builtin.specman
      push:
        - meta_scope: meta.function-call.builtin.specman
        - match: \s*(;)
          pop: true
          captures:
            1: punctuation.terminator.specman
        - include: code
    - match: (?:\s*{{valid_name}})\.({{list_pseudo_methods}}|{{built_in_member_functions}})\s*(\()
      captures:
        1: variable.other.specman
        2: keyword.function.builtin.specman
        3: punctuation.section.parens.begin.specman
      push:
        - meta_scope: meta.function-call.builtin.specman
        - match: (\))\s*(;)?
          pop: true
          captures:
            1: punctuation.section.parens.end.specman
            2: punctuation.terminator.specman
        - include: code

  built-in-variables:
    - match: \b({{built_in_variables}})\b
      captures:
        1: variable.language.specman

  # includes 15.1 Synchronization Actions
  code-blocks:
    - match: (\b{{concurrency_actions}}\b)?\s*\{
      captures:
        1: keyword.control.specman
      scope: punctuation.section.block.begin.specman
      push:
        - meta_content_scope: meta.code_block.specman
        - include: actions

  # code-blocks:
  #   - match: \{
  #     scope: punctuation.section.block.begin.specman
  #     # push:
  #     #- meta_content_scope: meta.code_block.specman
  #     #- match: '\}\s*(;)?'
  #     #  scope: punctuation.section.block.end.specman
  #     #  captures:
  #     #    1: punctuation.terminator.specman
  #     #  pop: true
  #     #- include: actions
  #     push:
  #     - include: actions

  preprocessor:
    - match: \s*(?:\}\s*)?(#\s*(?:ifdef|ifndef|else))\s*((?:`)?{{valid_id}})?\s*(\{)
      captures:
        1: keyword.control.import.specman
        2: variable.other.define.specman
        4: punctuation.section.block.begin.specman
      push:
      - meta_scope: meta.preprocessor.specman
      - include: code
      - include: struct-contents
      - match: \}
        scope: punctuation.section.block.end.specman
        pop: true

#######

  tbd:
    - scope: keyword.statement.specman
      match: \b(instance|on|event|expect|check|that|routine|specman|like|radix|hex|dec|bin|ignore|illegal|traceable|untraceable|cover|using|count_only|trace_only|at_least|transition|item|ranges|cross|text|call|task|within)\b

    - scope: variable.function.specman meta.function-call
      match: \b(initialize|non_terminal|testgroup|delayed|exit|finish|out|print|outf|appendf|post_generate|pre_generate|setup_test|finalize_test|extract_test|init|run|copy|set_config|quit|lock|unlock|release|swap|quit|to_string|value|stop_run|get_config|get_indices|get_enclosing_unit|hdl_path|exec|deep_compare|deep_compare_physical|pack|unpack)\b

    - scope: keyword.control.specman
      match: \b(start|until|repeat|while|for|from|to|step|each|do|break|continue|before|next|sequence|always|-kind|network|index|it|me|in|return|result)\b

    - scope: keyword.packing.specman
      match: \b(packing|low|high)\b

    - scope: keyword.conditional.specman
      match: \b(choose|matches|if|then|(?<!#\s)else|when|try)\b

    - scope: keyword.conditional.specman
      match: \b(case|casex|casez|default)\b

    - scope: keyword.temporal.specman
      match: \b(cycle|sample|events|forever|wait|change|negedge|rise|fall|delay|sync|sim|true|detach|eventually|emit)\b

    - scope: keyword.define.specman
      match: \b(as|computed|verilog|vhdl|variable|global|sys)\b

    - scope: keyword.control.import.specman
      match: \b(import)\b

    - scope: keyword.special.specman
      match: \b(untyped|symtab|ECHO|DOECHO)\b

    - scope: keyword.file.specman
      match: \b(files|load|module|ntv|source_ref|script|read|write)\b

    - scope: keyword.fsm.specman
      match: \b(initial|idle|others|posedge|clock|cycles)\b

    - scope: storage.type.specman
      match: \b{{built_in_types}}\b

    - scope: storage.type.list.specman
      match: list\s+of\s+\w+

    - scope: punctuation.terminator.specman
      match: \s*;
# end
